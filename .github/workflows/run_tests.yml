name: Run multicorn2 Tests

on:
  pull_request:

jobs:
  run_tests:
    name: run tests
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
      - uses: cachix/install-nix-action@v26
      - uses: zombiezen/setup-nix-cache-action@v0.4.0
        with:
          substituters: s3://mfenniak-multicorn2-nix-cache?region=us-west-2
          # NIX_CACHE_SECRET_KEY secret is generated by:
          #   nix key generate-secret --key-name mfenniak-multicorn2-nix-cache > ./secret
          # then "./secret" file is uploaded as secret NIX_CACHE_SECRET_KEY.
          secret_keys: ${{ secrets.NIX_CACHE_SECRET_KEY }}
          # Secrets AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY secrets are generated by creating a new AWS IAM user
          # which has these permissions, and then uploading an access key for that user to GitHub secrets.
          # {
          #     "Version": "2012-10-17",
          #     "Statement": [
          #         {
          #             "Sid": "VisualEditor0",
          #             "Effect": "Allow",
          #             "Action": [
          #                 "s3:PutObject",
          #                 "s3:GetObject",
          #                 "s3:ListBucket"
          #             ],
          #             "Resource": [
          #                 "arn:aws:s3:::mfenniak-multicorn2-nix-cache/*",
          #                 "arn:aws:s3:::mfenniak-multicorn2-nix-cache"
          #             ]
          #         }
          #     ]
          # }
          aws_access_key_id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_access_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      # allPostgresWithPlPython represents all the supported PostgreSQL versions that have been compiled against all
      # the supports Python versions, for the PL/Python language support required for some of the tests.  Here, we
      # build those versions and then push them to the binary cache, ensuring that they don't have to be rebuilt
      # unless something significant to them changes.  If they're already built, they'll just be pulled down from the
      # cache.
      #
      # It might make sense to just do the copy up to the cache after the test run, as that would avoid downloading
      # the PG builds if the tests are already run.  However, this way ensures that even if the tests fail, we still
      # get the PG builds up to the cache to make reruns faster.  It's a tradeoff.
      - run: nix build .#allPostgresWithPlPython
      - run: echo "${{ secrets.NIX_CACHE_SECRET_KEY }}" > ./nix-cache-cache-priv-key.pem
      - run: nix store sign --all --key-file ./nix-cache-cache-priv-key.pem
      - run: rm ./nix-cache-cache-priv-key.pem
      - run: nix copy ".#allPostgresWithPlPython" --to 's3://mfenniak-multicorn2-nix-cache?region=us-west-2'
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      # Now we run all the tests.
      - run: nix build .#allTestSuites
      # Although there isn't much "built" in the allTestSuites derivation, by copying it to the cache we'll avoid any
      # rebuilds to support tests that were already run.
      - run: nix copy ".#allTestSuites" --to 's3://mfenniak-multicorn2-nix-cache?region=us-west-2'
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
